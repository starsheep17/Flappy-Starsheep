<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Starsheep</title>
  <style>
    /* Your CSS styles here */
  </style>
</head>
<body>
  <!-- Your game canvas or elements here -->
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script>
    // Your JavaScript game code here
    // For example, the Flappy Starsheep game logic drawing on the canvas
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Starsheep17</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: linear-gradient(180deg, #000011, #000022);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #000;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
// Flappy Starsheep17 â€” simplified version

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

let frames = 0;
let score = 0;
let gameOver = false;

// Sheep sprite (simple circle with winking eye)
function drawSheep(x, y, wink) {
  ctx.save();
  ctx.translate(x, y);
  // Body
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.ellipse(0, 0, 25, 20, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.beginPath();
  ctx.ellipse(30, -5, 15, 15, 0, 0, Math.PI * 2);
  ctx.fill();
  // Eye
  ctx.fillStyle = '#000';
  if (wink) {
    ctx.beginPath();
    ctx.moveTo(35, -10);
    ctx.lineTo(45, -10);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.arc(40, -10, 4, 0, Math.PI * 2);
    ctx.fill();
  }
  // Smile
  ctx.beginPath();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.arc(35, 0, 8, 0, Math.PI, false);
  ctx.stroke();
  ctx.restore();
}

// Star background
const stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({
    x: Math.random() * WIDTH,
    y: Math.random() * HEIGHT,
    radius: Math.random() * 1.2,
    twinkle: Math.random(),
  });
}

function drawStars() {
  stars.forEach(star => {
    ctx.beginPath();
    const alpha = 0.5 + 0.5 * Math.sin(frames * 0.05 + star.twinkle * Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Pipes
const PIPE_WIDTH = 50;
const PIPE_GAP = 150;
const PIPE_SPEED = 2;
const pipes = [];

function createPipe() {
  const topHeight = 50 + Math.random() * (HEIGHT - PIPE_GAP - 100);
  pipes.push({
    x: WIDTH,
    top: topHeight,
    bottom: HEIGHT - (topHeight + PIPE_GAP),
  });
}

function drawPipe(pipe) {
  ctx.fillStyle = '#228B22';
  // Top pipe
  ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);
  // Bottom pipe
  ctx.fillRect(pipe.x, HEIGHT - pipe.bottom, PIPE_WIDTH, pipe.bottom);
}

// Sheep physics
const GRAVITY = 0.4;
const JUMP = -8;

let sheep = {
  x: 80,
  y: HEIGHT / 2,
  speed: 0,
  width: 50,
  height: 40,
};

function resetGame() {
  pipes.length = 0;
  score = 0;
  sheep.y = HEIGHT / 2;
  sheep.speed = 0;
  frames = 0;
  gameOver = false;
}

// Controls
document.body.addEventListener('touchstart', jump);
document.body.addEventListener('mousedown', jump);
function jump() {
  if (gameOver) {
    resetGame();
  } else {
    sheep.speed = JUMP;
  }
}

// Collision detection
function collide(pipe) {
  // Sheep box
  let sx = sheep.x;
  let sy = sheep.y - sheep.height/2;
  let sw = sheep.width;
  let sh = sheep.height;

  // Top pipe box
  let px = pipe.x;
  let py = 0;
  let pw = PIPE_WIDTH;
  let ph = pipe.top;

  // Bottom pipe box
  let pbY = HEIGHT - pipe.bottom;
  let pbH = pipe.bottom;

  // Check top pipe collision
  if (sx + sw > px && sx < px + pw && sy < ph) return true;
  // Check bottom pipe collision
  if (sx + sw > px && sx < px + pw && sy + sh > pbY) return true;

  return false;
}

// Game loop
function update() {
  frames++;

  // Add pipes every 100 frames
  if (frames % 100 === 0) {
    createPipe();
  }

  // Move pipes
  pipes.forEach(pipe => {
    pipe.x -= PIPE_SPEED;
  });

  // Remove offscreen pipes & update score
  if (pipes.length && pipes[0].x < -PIPE_WIDTH) {
    pipes.shift();
    score++;
  }

  // Apply gravity
  sheep.speed += GRAVITY;
  sheep.y += sheep.speed;

  // Boundary check
  if (sheep.y + sheep.height/2 > HEIGHT || sheep.y - sheep.height/2 < 0) {
    gameOver = true;
  }

  // Collision check
  pipes.forEach(pipe => {
    if (collide(pipe)) {
      gameOver = true;
    }
  });

  // Draw everything
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawStars();
  pipes.forEach(drawPipe);

  // Draw sheep, wink every 30 frames
  const wink = Math.floor(frames / 30) % 2 === 0;
  drawSheep(sheep.x, sheep.y, wink);

  // Draw score
  ctx.fillStyle = '#FFF';
  ctx.font = '30px Arial';
  ctx.fillText(`Score: ${score}`, 10, 50);

  if (!gameOver) {
    requestAnimationFrame(update);
  } else {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#FFF';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', WIDTH/2, HEIGHT/2 - 20);
    ctx.font = '20px Arial';
    ctx.fillText('Tap or click to restart', WIDTH/2, HEIGHT/2 + 20);
  }
}

resetGame();
update();
</script>
</body>
</html>
